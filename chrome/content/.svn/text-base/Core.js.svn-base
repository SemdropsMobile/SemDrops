/**
 * EL nucleo es el encargado de centralizar todos los "objetos" del plugin
 * la idea del nucleo es poder ser el mediador entre los distintos elementos que 
 * componen el plugin, nada puede acceder a otra cosa sin pasar primero por el 
 * nucleo.
 * 
 * @param {Referencia a DisckStorageManager} _dsm
 * @param {Referencia a Browser} _browser
 * @param {Referencia a WikiStorageManager} _wsm
 */

/** crosspage tomara el valor de la pagina donde nosotros iremos a buscar los datos semanticos de otra wikisemantica*/
var crosspage;
var browser;
var cantidad;
var crossCant;

function Core(_dsm,_browser,_wsm)
{
	this._dsm;
	this._browser;
	this._menu;
	this._mouse;
	this._labels;
	this._cant;
	this._selected;
	this._confgwind;
	this._wsm;
	this._awarenes;
	this._timer;
	
/**
 *  EL "initialize" es la primera funcion que se ejecuta a nivel de objetos, su objetivo principal es poder inizializar
 *  todas las variables del objeto CORE, una vez inicializadas procede a la carga de los elementos cargados en las 
 *  wikis de los usuarios gracias a las dos funciones "readWikiUserData()" y "loadWikiData()".
 */	
	this.initialize = function (c,a,l)
									{
										_cant = 0;
										_browser.initialize();
										browser = _browser;
										_dsm.initialize();
										cantidad = 1;
										_dsm.createTable();
										_dsm.readInDB();
										c.initialize();
										a.initialize();
										l.initialize();
										_labels = new Array(4);
										_labels[1] = c;
										_labels[2] = l;
										_labels[3] = a;
										_timer = Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
										_menu = new Array(2);
										_menu[0] = new menuEtiqueta();	
										_menu[1] = new menuValor();
										_confgwind = new ConfigureWindow();
										readWikiUserData(_browser);
										_wsm.initialize(_browser);
										_awarenes = new AwarenessManager();
										_awarenes.initialize();
									}
									
	this.increment = function ()
								{
									_cant++;
								}
	/**
	 *  "selected" retorna el elemento seleccionado a nivel de interfaz del semdrop, estos elementos pueden ser
	 *  un tag (categoria, link, atributo), o uno de sus respectivos valores.
	 */
	this.selected = function () 
								{
									return(_selected);
								}	
	/**
	 * "setselected()" setea un nuevo elemento en el momento en que el mouse selecciona un tag o su respectivo
	 * valor en la interfaz de semdrop. 
	*/
	this.setselected = function (sel)							
								{
									_selected = sel;
								}
	/**
	 * "agregar" funciona como intermedio entre la interfaz y el objeto LABEL, cualquier tag que se quiera agregar al 
	 * semdrop pasara primero por el core quien lo deriba a su respectivo label.
	 */
	this.agregar = function ()	
								{	
									var i = _selected.getAttribute('idCont');
									_labels[i].add(this,"Value" + CANTVAL,"Attribute");
								}
	/**
	 * Idem agregar solo que borra.
	 */							
	this.borrar = function ()	
								{	
									var cell = core.selected();
									var row = cell.parentNode;
									var item = row.parentNode;
									var fin = item.parentNode;
									i = fin.getAttribute('id');
									_labels[i].del(this,fin,item);
								}	
	/**
	 * Idem agregar solo que modifica.
	 */							
	this.modificar = function()
								{
									var cell = core.selected();
									var row = cell.parentNode;
									var item = row.parentNode;
									var fin = item.parentNode;
									i = fin.getAttribute('id');
									_labels[i].mod(this);
								}
	/**
	 * "loadInDisk" se encarga de almacenar los elementos tags en disco, por el moemnto es una funcion OBSOLETA
	 */							
	/*this.loadInDisk = function(value,tag)
								{
									value += "Âª";
									var i = tag.getAttribute('idCont');
									value = _labels[i].changeValue(value);
									_dsm.write(value,value.length);
								}*/
	/**
	 * "loadInWiki" se encarga de almacenar el contenido de un nuevo tag dentro de la wiki que el usuario setea como
	 * destino. para ello deriva el almacenamiento al objeto WIKISTORAGEMANAGER (_wsm)
	 */							
	this.loadInWiki = function (value,attribute,tag)
								{
								    var i = tag.getAttribute('idCont');
									_wsm.write(value,attribute,i);
								}
	/**
	 * funcion OBSOLETA que se encarga de levantar los datos del disco local del usuario.
	 */							
	/*this.cargar = function()
							{
								_dsm.cargar(this);
							}*/
	/**
	 * cuando el mouse de la vista selecciona un nuevo tag este dispara la funcion "select", la cual setea el nuevo
	 * elemento seleccionado.
	 */						
	this.select = function (event)
									{
										var t = event.target.currentIndex;
										var father = event.target.view.getItemAtIndex(t);
										var sun1 = father.childNodes[0];
										var sun2 = sun1.childNodes[0];	
										_selected = sun2;
										_browser.refreshPageSelected(event,sun2);
										var i = _selected.getAttribute('menu');
										_menu[i].menu();
									}	
	/**
	 * Funcion que delega al WIKISTORAGEMANAGER el borrado de un elemento seleccionado desde la aplicacion. La linea
	 * que se encuentra comentada es porque antes los tags se almacenaban de manera local.
	 */								
	this.deleteFile = function (word,attribute)
									{
										//_dsm.deleteFile(word);
										_wsm.dellete(word,attribute);
									}
	/**
	 * Idem deleteFile pero modificando.
	 */								
	this.modifiFile = function (word,newword,secon,oldattri)
									{
										//_dsm.modifiFile(word,newWord);
										_wsm.modifi(word,oldattri,newword,secon);
									}								
	/**
	 * retorna el objeto CATEGORY que se corresponde con los datos del tag Categoria en la aplicacion.
	 */								
	this.category = function ()
									{
										return (_labels[1].getself());
									}
	/**
	 * Idem category pero con le tag link.
	 */								
	this.links = function ()
									{
										return (_labels[2].getself());
									}
	/**
	 * Idem category pero con le tag attributos.
	 */									
	this.attributes = function ()
									{
										return (_labels[3].getself());
									}
									
	this.getcategory = function ()
									{
										return (_labels[1]);
									}
									
	this.getlinks = function ()
									{
										return (_labels[2]);
									}
									
	this.getattributes = function ()
									{
										return (_labels[3]);
									}								
	/**
	 * Cuando se produce un evento de movimiento de mouse la aplicacion compara si la pagina que visualiza el semdrop
	 * es la misma a la que visualiza el navegador. en caso de no ser asi, el semdrops hace un refresh con la nueva 
	 * pagina.
	 */								
	this.comparar = function ()
									{
										if (_browser.compare())
										{
											window.location.reload();
											this.onLoad();
										}
									}
	/**
	 * Retorna el objeto DISKSTORAGEMANAGER el cual se encuentra obsoleto.
	 */								
	this.diskstoragemanager = function ()
									{
										return _dsm;
									}
								
	this.refreshPageSelected = function (event)
									{
										_browser.refresPageSelected(event,this);
									}
	/**
	 *  share y unshare son funciones obsoletas cuyo objetivo es cambiar el icono de los tags cuando pasaban a ser 
	 *  compartidos.
	 */
	/*this.share = function ()
									{
										_selected.setAttribute('src',"amsn24.png");
									}	
									
	this.unshare = function ()
									{
										_selected.setAttribute('src',"noshare.png");
									}*/
	/**
	 * Cuando un usuario pone a compartir un tag se dispara la funcion publish, la cual deriba la responsabilidad al 
	 * WIKISTORAGEMANAGER, quien publica en la wiki visualizada por el browser el valor del elemenento de mi tag.
	 */								
	this.publish = function()								
									{
										var cell = core.selected();
										var row = cell.parentNode;
										var item = row.parentNode;
										var fin = item.parentNode;
										var i = fin.getAttribute('id');
										var cont = 0;
										_wsm.publish(this,i);
									}
	/**
	 * Dispara la ventana de configuracion una vez precionado el respectivo boton.
	 */								
	this.configure = function ()
									{
										_confgwind.initialize();
									}
	/**
	 * Almacena los valores de la configuracion seleciconada dentro de un archivo local.
	 */								
	this.storageconfig = function (name,wiki)
									{
										_dsm.loadInDB(name,wiki);
									}
	/**
	 *  Esta funcion permite refrescar la pagina con el valor del elento en el cual se disparo la opcion. si es una
	 *  category semdrops refrescara la pagina con el valor de la categoria pero dentro de la wiki local del usuario
	 *  donde el tiene almacenado todas las anotaciones, si en cambio es un link o un atributo el semdrop refrescara 
	 *  la pagina en la misma wiki que el usuario esta visualizando. 
	 */
	this.navigate = function ()
									{
										var value = this.selected().getAttribute('label');
										var personalwiki = document.getElementById("wikiname").value;
										var cell = core.selected();
										var row = cell.parentNode;
										var item = row.parentNode;
										var fin = item.parentNode;
										var i = fin.getAttribute('id');
										if (i == 1)
										{
											_browser.refresh(personalwiki+"/Category:"+value);
										}
										else
										{
											value = row.childNodes[1].getAttribute('label');
											personalwiki = _browser.getActualUri();
											var cont = -1;
											for (i=personalwiki.length; personalwiki[i] != "/" || i == 0;i--)
											{
												cont++;	
											}
											_browser.refresh(personalwiki.substring(0,personalwiki.length-cont)+value);
										}
									}
}

// DE AHORA EN ADELANTE LAS FUNCIONES SON AJENAS AL OBJETO CORE, EL LAS PUEDE USAR PERO ESTAN INVISIBLES PARA EL RESTO
// DE LOS OBJETOS QUE COMPONEN EL SEMDROPS.


var name = '';
var rdf;
var rdf2;
var id;
/**
 *  loadWikiData es una funcion que lee los elementos desde la wiki que el browser esta visualizando, cargando los 
 *  datos dentro de la vista del semdrops.
 */
function loadWikiData(browser)
{
	rdf = new RDF();
	crossCant = 10;
	var url = browser.getActualUri();
	var cont=-1;
	var url_firstpart='';
	
	if (url != "about:blank")
	{
		for (var i=url.length; url[i] != "/" || i <= 0;i--)
		{
			cont++;	
		}
		for (var i=0;i<(url.length - cont);i++)
		{
			url_firstpart += url[i];
		}
		for (var j=0;j < (url.length - url_firstpart.length);j++)
		{
			name += url[j+url_firstpart.length];
		}
		var RDFurl = url_firstpart+'Special:ExportRDF/'+name;
		id = 0;
		
		var xmlreq = xmlhttp = new XMLHttpRequest();
		xmlreq.onreadystatechange = function ()
		{
			if (xmlreq.status != 200)
			{
				if (cantidad != 0){cantidad=0;delayOfCrossWikiData();}
			}	
			if (xmlreq.readyState == 4 && xmlreq.status == 200)
			{
				rdf.getRDFURL(RDFurl,callback);
			}
		};
		xmlreq.open("GET",RDFurl,true);
		xmlreq.send(null);
	}
}

function delayOfCrossWikiData()
{
	var cross_cont = 0;
	crossCant=0;
	loadCrossWikiData(browser,cross_cont);
}

function loadCrossWikiData(browser,cross_cont)
{
	rdf = new RDF();
	// ESTA LINEA USA EL PRIMERO DE LOS "RELATIVE URL" PARA DESPUES HAY QUE CAMBIARLO POR LA VARIABLE CROSS_CONT
	var url = crosspage[cross_cont].object;
	var cont=-1;
	var url_firstpart='';
	var last_uri='';
	
	if (url != "about:blank")
	{
		for (var i=url.length; url[i] != "/" || i <= 0;i--)
		{
			cont++;	
		}
		for (var i=0;i<(url.length - cont);i++)
		{
			url_firstpart += url[i];
		}
		for (var j=0;j < (url.length - url_firstpart.length);j++)
		{
			if (url[j+url_firstpart.length] != " ")
			{	last_uri += url[j+url_firstpart.length];}	
		}
		var RDFurl = url_firstpart+'Special:ExportRDF/'+last_uri;
		id = 0;
		
		var xmlreq = xmlhttp = new XMLHttpRequest();
		xmlreq.onreadystatechange = function ()
		{
			if (xmlreq.readyState == 4)
			{
				rdf.getRDFURL(RDFurl,callback);
			}
		};
		xmlreq.open("GET",RDFurl,true);
		xmlreq.send(null);
	}	
}

/**
 * readWikiUserData realiza el mismo efecto que loadWikiData, la unica diferencia es que en lugar de hacerlo desde la 
 * wiki que se esta visualizando en ese momento lo hace desde la wiki que el usuario tiene seteada.  
 */

function readWikiUserData(bro)
{
	rdf = new RDF();
	var url = document.getElementById("wikiname").getAttribute('value')+"/Special:ExportRDF/"+document.getElementById("username").getAttribute('value')+"-"+bro.getActualUri()+"wikistorage";
	id = 1;
	var xmlreq = xmlhttp = new XMLHttpRequest();
	xmlreq.onreadystatechange = function ()
	{
		if (xmlreq.readyState == 4)
		{
			rdf.getRDFURL(url,callbackUserData);
		}
	};
	xmlreq.open("GET",url,true);
	xmlreq.send(null);
}

/**
 * Carga los valores de los atributos y de los links en la vista del semdrop.
 */
function cargarAlTagAttributeAndLink(attritag,attrival,linktag,linkval)
{
	for(i=0;i < linkval.length;i++)
	{
		if (linkval[i] != '')
		{
			_awarenes.compareLinks(linktag,linkval,id,crossCant);
		}
	}
	for(i=0;i < attrival.length;i++)
	{
		if (attrival[i] != '')
		{
			_awarenes.compareAttributes(attritag,attrival,id,crossCant);
		}
	}
	if (cantidad != 0){cantidad = 0;delayOfCrossWikiData();}
}

/**
 *  Carga el valor de los elemntos leidos en la wiki con dentro del semdrops.
 */

function loadUserTagLink(tag,val)
{
	for(i=0;i < val.length;i++)
	{
		if (val[i] != '')
		{
			_awarenes.loadUserLinkData(tag,val,id,i);
		}
	}
	loadWikiData(browser);
}

/**
 * Esta funcion se dispara cuando se crea el RDFparser, una vez el objeto es creado dispara esta funcion con el 
 * objetivo de poder obtener todos los elementos del RDF de la wiki visualizada por en el momento.
 */
function callback()
{
	var subject = rdf.Match(null,null,null,null);
	var subject_array =rdf.Match(null,subject[3].subject,null,null);
	var atrib1;
	
	categoria(subject[3].subject,subject[3].predicate);
	
	var rdfattributeTags = new Array(subject_array.lenght);
	var rdfattributeValues = new Array(subject_array.lenght);
	var rdflinkTags = new Array(subject_array.lenght);
	var rdflinkValues = new Array(subject_array.lenght);
	
	for (i=0;i<subject_array.length;i++)
	{
		rdfattributeTags[i] = '';
		rdfattributeValues[i] = '';
		rdflinkTags[i] = '';
		rdflinkValues[i] = '';
		atrib1 = rdf.Match(null,subject_array[i].predicate,null,null);
		if (atrib1 != '') 
		{
			atrib2 = rdf.Match(null,atrib1[0].subject,'http://www.w3.org/2000/01/rdf-schema#label',null);
			if (atrib2 != '')
			{
				if (subject_array[i].object[5] != '/' && subject_array[i].object[6] != '/')
				{
					rdfattributeTags[i] = atrib2[0].object;
					rdfattributeValues[i] = subject_array[i].object;
				}
				else
				{
					var atrib3 = rdf.Match(null,subject_array[i].object,null,null);
					rdflinkTags[i] = atrib2[0].object;
					rdflinkValues[i] = atrib3[1].object;
				}
			}
		}
	}
	cargarAlTagAttributeAndLink(rdfattributeTags,rdfattributeValues,rdflinkTags,rdflinkValues);
	if(crossCant != crosspage.length)
	{
		crossCant++;
		loadCrossWikiData(browser,crossCant);
		}
}
/**
 * Idem callback pero a diferencia esta se ejecuta sobre la wiki personal del usuario.
 */
function callbackUserData()
{
	var subject =rdf.Match(null,null,null,null);
	var subject_array = rdf.Match(null,subject[3].subject,null,null);
	
	crosspage = rdf.Match(null,subject[3].subject,"http://www.w3.org/2002/07/owl#sameAs",null);
		
	var atrib1;
	loadCategoryTagUserData(subject[3].subject,subject[3].predicate);
	
	var rdfTags = new Array(subject_array.lenght);
	var rdfValues = new Array(subject_array.lenght);
	
	var rdfTags = new Array(subject_array.lenght);
	var rdfValues = new Array(subject_array.lenght);
	
	for (i=0;i<subject_array.length;i++)
	{
		rdfTags[i] = '';
		rdfValues[i] = '';
		atrib1 = rdf.Match(null,subject_array[i].predicate,null,null);
		if (atrib1 != '') 
		{
			atrib2 = rdf.Match(null,atrib1[0].subject,'http://www.w3.org/2000/01/rdf-schema#label',null);
			if (atrib2 != '')
			{
				rdfTags[i] = atrib2[0].object;
				if (subject_array[i].object[5] != '/' && subject_array[i].object[6] != '/')
				{
					rdfValues[i] = subject_array[i].object;
				}
				else
				{
					var atrib3 = rdf.Match(null,subject_array[i].object,null,null);
					rdfValues[i] =atrib3[1].object;
				}
			}
		}
	}
	loadUserTagLink(rdfTags,rdfValues);
}
/**
 * esta funcion carga todos los elementos extraidos del RDF y se los envia al objeto AWARNESSMANAGER, el cual los 
 * compara entre si con los elementos de la wiki visualizada por el browser y se los envia a la vista para que el 
 * usuario pueda visualizarlos.
 */
function categoria(subject,predicate)
{
	var subject_array =rdf.Match(null,subject,predicate,null);
	var cat_array = new Array(subject_array.length);
	for (i=0;i<subject_array.length;i++)
	{
		var cat = rdf.Match(null,subject_array[i].object,null,null);
		var cat = rdf.Match(null,subject_array[i].object,null,null);
		if (cat != '' && cat[1].object[5] != '/' && cat[1].object[6] != '/')
		{
			_awarenes.compareCategories(cat,id,crossCant);
		}
	}
}
/**
 * Idem categoria solo que esta funcion como se ejecuta primero no compara ningun elemento, ya que no tiene nada que 
 * comparar.
 */
function loadCategoryTagUserData(subject,predicate)
{
	var subject_array = rdf.Match(null,subject,predicate,null);
	var cat_array = new Array(subject_array.length);
	for (i=0;i<subject_array.length;i++)
	{
		var cat = rdf.Match(null,subject_array[i].object,null,null);
		var cat = rdf.Match(null,subject_array[i].object,null,null);
		if (cat != '' && cat[1].object[5] != '/' && cat[1].object[6] != '/')
		{
			_awarenes.loadCategoriesUserData(cat,id);
		}
	}
}